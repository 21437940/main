# A0131140E
###### ./src/main/antlr4/cs2103/v15_1j/jimjim/antlr4/UserCommand.g4
``` g4
grammar UserCommand;

@lexer::header { 
import java.util.Map;
}

@lexer::members {
    Map<String, Integer> aliases = null;

    public void setAliases(Map<String, Integer> aliases) {
        this.aliases = aliases;
    }
}

cmd:	delCmd
    |   markDoneCmd
    |   unmarkCmd
    |   searchCmd
    |   changeCmd
    |   hideSearchCmd
    |   undoCmd
    |   redoCmd
    |   helpCmd
    |   aliasCmd
    |   showHideCmd
    |   saveLocationCmd
    |   addCmd  // should be the last rule to check
	;
	
delCmd: DELETE ITEM_NUM;

markDoneCmd:    MARK ITEM_NUM (AS DONE)?;

unmarkCmd:  UNMARK ITEM_NUM;

searchCmd:  SEARCH (filter ',')* filter;

changeCmd:  (RESCHEDULE|EXTEND|SHIFT|(CHANGE START?)|(CHANGE END))
            ITEM_NUM TO? (date|time|datetime)           # changeOneTime
        |   (RESCHEDULE|EXTEND|SHIFT|CHANGE)
            ITEM_NUM TO? date FROM? time TO time        # changeStartEndCommonDate
        |   (RESCHEDULE|EXTEND|SHIFT|CHANGE)
            ITEM_NUM TO? FROM? time TO time             # changeStartEndTimeOnly
        |   (RESCHEDULE|EXTEND|SHIFT|CHANGE)
            ITEM_NUM TO? FROM? datetime TO datetime     # changeStartEndDateTime
        |   (RENAME|(CHANGE NAME?)) ITEM_NUM TO? string # rename
        ;

hideSearchCmd:   HIDE SEARCH;

undoCmd:    UNDO;

redoCmd:    REDO;

showHideCmd: (SHOW|HIDE) (OVERDUE|COMPLETED|DONE);

helpCmd:    HELP helpPage?;

aliasCmd:   ALIAS ADD aliasable (WORD|aliasable)    # aliasAdd
    |       ALIAS DELETE (WORD|aliasable)           # aliasDelete
    |       ALIAS (LIST|SHOW)                       # aliasList
    ;
    
saveLocationCmd:    SAVE TO string;

addCmd: string BY (date|time|datetime)      # addTask
    |   string ON date FROM? time TO time   # addEventCommonDate
    |   string (ON|AT|FROM)? datetime (TO (datetime|time))?   # addEvent
    |   string FROM? time TO time           # addEventWithoutDate
    |   string                              # addFloatingTask
    ;
    
aliasable:  DELETE
    |       UNMARK
    |       MARK
    |       SEARCH
    |       CONTAIN
    |       RESCHEDULE
    |       RENAME
    |       CHANGE
    |       EXTEND
    |       HIDE
    |       UNDO
    |       REDO
    |       HELP
    |       ALIAS
    |       ADD
    |       LIST
    |       SHOW
    ;
    
helpPage:   DATE
    |       TIME
    |       COMMON
    |       ADD
    |       DELETE
    |       MARK
    |       UNMARK
    |       CHANGE
    |       SEARCH
    |       ALIAS
    ;
	
string:   .+?;
/* Note: 10 Jan 11 will be understood as 10 Jan of the year 11
 * to specify 10 January, 11 o'lock, make 11 more explicit as a
 * time e.g. 11.00, 11 a.m., etc.
 * to specify 10 o'clock, 11 January, make 10 more explicit as a
 * time
 */ 
datetime:   date AT? time   # dateThenTime
        |   time ON? date   # timeThenDate
        ;
date:   TODAY                               # today
    |   TOMORROW                            # tomorrow
    |   (THIS|NEXT)? DAY_OF_WEEK            # dayOfWeek
    |   INT ('/'|'-') INT (('/'|'-') INT)?  # fullDate
    |   INT ORDINAL? ('/'|'-'|',')? MONTH_NAME (('/'|'-'|',')? INT)? # fullDateWordMonth
    |   MONTH_NAME ('/'|'-'|',')? INT ORDINAL? (('/'|'-'|',')? INT)? # fullDateWordMonthMonthFirst
    ;
time:   timeWithPeriod
    |   timeWithoutPeriod
    ;
timeWithPeriod: INT (('.'|':') INT)? (AM|PM)
    ;
timeWithoutPeriod:  INT (('.'|':') INT)? OCLOCK?
    ;


filter: (BEFORE|AFTER) date             # dateRangeFilter
    |   BETWEEN date AND date           # betweenDateFilter
    |   (BEFORE|AFTER) time             # timeRangeFilter
    |   BETWEEN time AND time           # betweenTimeFilter
    |   (BEFORE|AFTER) datetime         # dateTimeRangeFilter
    |   BETWEEN datetime AND datetime   # betweenDateTimeFilter
    |   THIS WEEK                       # thisWeekFilter
    |   NEXT WEEK                       # nextWeekFilter
    |   THIS MONTH                      # thisMonthFilter
    |   NEXT MONTH                      # nextMonthFilter
    |   AT? time                        # timeFilter
    |   ON? date                        # dateFilter
    |   OVERDUE                         # overdueFilter
    |   CONTAIN? string                 # keywordFilter
    ;


BY:	[Bb][Yy];
FROM: [Ff][Rr][Oo][Mm];
TO:	[Tt][Oo];
AT: [Aa][Tt];
ON: [Oo][Nn];
BEFORE: [Bb][Ee][Ff][Oo][Rr][Ee];
AFTER: [Aa][Ff][Tt][Ee][Rr];
BETWEEN: [Bb][Ee][Tt][Ww][Ee][Ee][Nn];
AND: [Aa][Nn][Dd];

AM: [Aa].?[Mm].?;
PM: [Pp].?[Mm].?;

ORDINAL: ([Ss][Tt]) | ([Nn][Dd]) | ([Rr][Dd]) | ([Tt][Hh]);
OCLOCK: [Oo]['\''']?[Cc][Ll][Oo][Cc][Kk];
OVERDUE: [Oo][Vv][Ee][Rr][Dd][Uu][Ee];

DELETE: [Dd][Ee][Ll][Ee][Tt][Ee];
UNMARK: [Uu][Nn][Mm][Aa][Rr][Kk];
MARK: [Mm][Aa][Rr][Kk];
AS: [Aa][Ss];
DONE: [Dd][Oo][Nn][Ee];
COMPLETED: [Cc][Oo][Mm][Pp][Ll][Ee][Tt][Ee][Dd];
SEARCH: [Ss][Ee][Aa][Rr][Cc][Hh];
CONTAIN: [Cc][Oo][Nn][Tt][Aa][Ii][Nn]([Ss])?;
RESCHEDULE: [Rr][Ee][Ss][Cc][Hh][Ee][Dd][Uu][Ll][Ee];
RENAME: [Rr][Ee][Nn][Aa][Mm][Ee];
CHANGE: [Cc][Hh][Aa][Nn][Gg][Ee];
EXTEND: [Ee][Xx][Tt][Ee][Nn][Dd];
SHIFT: [Ss][Hh][Ii][Ff][Tt];
HIDE: [Hh][Ii][Dd][Ee];
UNDO: [Uu][Nn][Dd][Oo];
REDO: [Rr][Ee][Dd][Oo];
HELP: [Hh][Ee][Ll][Pp];
ALIAS: [Aa][Ll][Ii][Aa][Ss];
ADD: [Aa][Dd][Dd];
LIST: [Ll][Ii][Ss][Tt];
SHOW: [Ss][Hh][Oo][Ww];
SAVE: [Ss][Aa][Vv][Ee];

DATE: [Dd][Aa][Tt][Ee];
TIME: [Tt][Ii][Mm][Ee];
COMMON: [Cc][Oo][Mm][Mm][Oo][Nn];

NAME: [Nn][Aa][Mm][Ee];
START: [Ss][Tt][Aa][Rr][Tt];
END: [Ee][Nn][Dd];

TODAY: [Tt][Oo][Dd][Aa][Yy];
TOMORROW: [Tt][Oo][Mm][Oo][Rr][Rr][Oo][Ww];
THIS: [Tt][Hh][Ii][Ss];
NEXT: [Nn][Ee][Xx][Tt];

MONTH: [Mm][Oo][Nn][Tt][Hh];
WEEK: [Ww][Ee][Ee][Kk];

DAY_OF_WEEK:    [Mm][Oo][Nn]([Dd][Aa][Yy])?
            |   [Tt][Uu][Ee]([Ss][Dd][Aa][Yy])?
            |   [Ww][Ee][Dd]([Nn][Ee][Ss][Dd][Aa][Yy])?
            |   [Tt][Hh][Uu]([Rr][Ss][Dd][Aa][Yy])?
            |   [Ff][Rr][Ii]([Dd][Aa][Yy])?
            |   [Ss][Aa][Tt]([Uu][Rr][Dd][Aa][Yy])?
            |   [Ss][Uu][Nn]([Dd][Aa][Yy])?
            ;
MONTH_NAME:  [Jj][Aa][Nn]([Uu][Aa][Rr][Yy])?
    |   [Ff][Ee][Bb]([Rr][Uu][Aa][Rr][Yy])?
    |   [Mm][Aa][Rr]([Cc][Hh])?
    |   [Aa][Pp][Rr]([Ii][Ll])?
    |   [Mm][Aa][Yy]
    |   [Jj][Uu][Nn]([Ee])?
    |   [Jj][Uu][Ll]([Yy])?
    |   [Aa][Uu][Gg]([Uu][Ss][Tt])?
    |   [Ss][Ee][Pp]([Tt][Ee][Mm][Bb][Ee][Rr])?
    |   [Oo][Cc][Tt]([Oo][Bb][Ee][Rr])?
    |   [Nn][Oo][Vv]([Ee][Mm][Bb][Ee][Rr])?
    |   [Dd][Ee][Cc]([Ee][Mm][Bb][Ee][Rr])?
    ;
ITEM_NUM: [FfEeDd][0-9]+;
INT:[0-9]+;

WORD: [a-zA-Z]+
    {
        String word = getText().toLowerCase();
        if ((aliases != null) && (aliases.containsKey(word))) {
            setType(aliases.get(word));
        }
    }
    ;
WS: [ \t\r\n]+ -> skip;
```
###### ./src/main/java/cs2103/v15_1j/jimjim/parser/JJCommandVisitor.java
``` java
package cs2103.v15_1j.jimjim.parser;

import java.time.DateTimeException;
import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.Arrays;

import org.antlr.v4.runtime.tree.TerminalNode;

import cs2103.v15_1j.jimjim.antlr4.UserCommandBaseVisitor;
import cs2103.v15_1j.jimjim.antlr4.UserCommandParser;
import cs2103.v15_1j.jimjim.antlr4.UserCommandParser.OverdueFilterContext;
import cs2103.v15_1j.jimjim.command.*;
import cs2103.v15_1j.jimjim.searcher.*;

public class JJCommandVisitor extends UserCommandBaseVisitor<Command> {
	
	private LocalDateTime dateTime = LocalDateTime.MIN;
	private String string;
	private String userCommand;
	private ArrayList<Filter> filters;
	private ArrayList<String> keywords;
	
	public JJCommandVisitor(String userCommand) {
		this.userCommand = userCommand;
	}
	
	//----------TYPES OF COMMAND-------------

	@Override
	public Command visitAddFloatingTask(
			UserCommandParser.AddFloatingTaskContext ctx) {
		visit(ctx.string());
		return new AddCommand(string);
	}

	@Override
	public Command visitAddTask(UserCommandParser.AddTaskContext ctx) {
		visit(ctx.string());
		if (ctx.date() != null) {
            dateTime = dateTime.with(LocalTime.MAX);
            visit(ctx.date());
		} else if (ctx.time() != null) {
            dateTime = LocalDate.now().atStartOfDay();
            visit(ctx.time());
		} else if (ctx.datetime() != null) {
		    visit(ctx.datetime());
		} else {
		    assert false; // shouldn't happen
		}
		return new AddCommand(string, dateTime);
	}

	@Override
	public Command visitAddEvent(UserCommandParser.AddEventContext ctx) {
		visit(ctx.string());
		visit(ctx.datetime(0));
		LocalDateTime start = dateTime;
		if (ctx.time() != null) {
		    visit(ctx.time());
		} else if (ctx.datetime(1) != null) {
		    visit(ctx.datetime(1));
		} else {
		    // no end datetime specified, default 1 hour duration
		    dateTime = dateTime.plusHours(1);
		}
		LocalDateTime end = dateTime;
		if (start.isBefore(end)) {
		    return new AddCommand(string, start, end);
		} else {
		    return new InvalidCommand("Please ensure that the event's"
		            + " ending time is after its starting time");
		}
    }

	@Override
	public Command visitAddEventCommonDate(
	        UserCommandParser.AddEventCommonDateContext ctx) {
		visit(ctx.string());
		if (ctx.date() == null) {
		    dateTime = LocalDate.now().atStartOfDay();
		} else {
		    visit(ctx.date());
		}
		visit(ctx.time(0));
		LocalDateTime start = dateTime;
		visit(ctx.time(1));
		LocalDateTime end = dateTime;
		if (start.isBefore(end)) {
		    return new AddCommand(string, start, end);
		} else {
		    return new InvalidCommand("Please ensure that the event's"
		            + " ending time is after its starting time");
		}
    }

	@Override
	public Command visitAddEventWithoutDate(
	        UserCommandParser.AddEventWithoutDateContext ctx) {
		visit(ctx.string());
        dateTime = LocalDate.now().atStartOfDay();
		visit(ctx.time(0));
		LocalDateTime start = dateTime;
		visit(ctx.time(1));
		LocalDateTime end = dateTime;
		if (start.isBefore(end)) {
		    return new AddCommand(string, start, end);
		} else {
		    return new InvalidCommand("Please ensure that the event's"
		            + " ending time is after its starting time");
		}
    }
	
	@Override
    public Command visitDelCmd(UserCommandParser.DelCmdContext ctx) {
	    String itemNum = ctx.ITEM_NUM().getText().toLowerCase();
        return new DeleteCommand(itemNum.charAt(0),
                Integer.parseInt(itemNum.substring(1)));
    }

	@Override
	public Command visitMarkDoneCmd(UserCommandParser.MarkDoneCmdContext ctx) {
	    String itemNum = ctx.ITEM_NUM().getText().toLowerCase();
        return new MarkDoneCommand(itemNum.charAt(0),
            Integer.parseInt(itemNum.substring(1)));
    }
	
	@Override
	public Command visitUnmarkCmd(UserCommandParser.UnmarkCmdContext ctx) {
	    String itemNum = ctx.ITEM_NUM().getText().toLowerCase();
        return new UnmarkCommand(itemNum.charAt(0),
            Integer.parseInt(itemNum.substring(1)));
    }
	
	@Override
	public Command visitSearchCmd(UserCommandParser.SearchCmdContext ctx) {
	    filters = new ArrayList<>();
	    keywords = new ArrayList<>();
	    visitChildren(ctx);
	    // combine all keyword filters into 1 for efficiency
	    if (keywords.size() > 0) {
	        filters.add(new KeywordFilter(keywords));
	    }
	    return new SearchCommand(filters);
	}
	
	@Override
	public Command visitHideSearchCmd(UserCommandParser.HideSearchCmdContext ctx) {
	    return new HideSearchCommand();
	}

	@Override
	public Command visitHelpCmd(UserCommandParser.HelpCmdContext ctx) {
	    if (ctx.helpPage() != null) {
            return new HelpCommand(ctx.helpPage().getText().toLowerCase());
	    } else {
	        return new HelpCommand("index");
	    }
	}
	
	@Override
	public Command visitUndoCmd(UserCommandParser.UndoCmdContext ctx) {
	    return new UndoCommand();
	}
	
	@Override
	public Command visitRedoCmd(UserCommandParser.RedoCmdContext ctx) {
	    return new RedoCommand();
	}
	
	@Override
	public Command visitRename(UserCommandParser.RenameContext ctx) {
	    String itemNum = ctx.ITEM_NUM().getText().toLowerCase();
        char prefix = itemNum.charAt(0);
        int taskNum = Integer.parseInt(itemNum.substring(1));
	    visit(ctx.string());
	    return new ChangeCommand(prefix, taskNum, string, null, null, null, null);
	};
	
	@Override
	public Command visitChangeOneTime(UserCommandParser.ChangeOneTimeContext ctx) {
	    String itemNum = ctx.ITEM_NUM().getText().toLowerCase();
        char prefix = itemNum.charAt(0);
        int taskNum = Integer.parseInt(itemNum.substring(1));
        LocalDate date = null;
        LocalTime time = null;
        if (ctx.date() != null) {
            visit(ctx.date());
            date = dateTime.toLocalDate();
        } else if (ctx.time() != null) {
            visit(ctx.time());
            time = dateTime.toLocalTime();
        } else if (ctx.datetime() != null) {
            visit(ctx.datetime());
            date = dateTime.toLocalDate();
            time = dateTime.toLocalTime();
        } else {
            assert false;   // shouldn't happen
        }
        if (ctx.SHIFT() != null) {
            // change start time, end time automatically changed
            return new ShiftCommand(prefix, taskNum, date, time);
        } else if ((ctx.EXTEND() != null) | (ctx.END() != null)) {
            // change end time
            return new ChangeCommand(prefix, taskNum, null, null, null, date, time);
        } else if ((ctx.RESCHEDULE() != null) | (ctx.CHANGE() != null)) {
            // change start time
            return new ChangeCommand(prefix, taskNum, null, date, time, null, null);
        } else {
            assert false; // shouldn't happen
            return null;
        }
	};
	
	@Override
	public Command visitAliasAdd(UserCommandParser.AliasAddContext ctx) {
	    if (ctx.aliasable(1) == null) {
	        // not specifying a keyword as alias
            return new AliasAddCommand(ctx.WORD().getText().toLowerCase(),
                                       ctx.aliasable(0).getStart().getType(),
                                       ctx.aliasable(0).getText());
	    } else {
	        return new InvalidCommand("\"" + ctx.aliasable(1).getText() + "\""
	                + " is already a keyword and cannot be made an alias!");
	    }
	}

	@Override
	public Command visitAliasDelete(UserCommandParser.AliasDeleteContext ctx) {
	    if (ctx.WORD() != null) {
            return new AliasDeleteCommand(ctx.WORD().getText().toLowerCase());
	    } else if (ctx.aliasable() != null) {
            return new AliasDeleteCommand(ctx.aliasable().getText().toLowerCase());
	    } else {
	        assert false; //shouldn't happen
	        return null;
	    }

	}

	@Override
	public Command visitAliasList(UserCommandParser.AliasListContext ctx) {
	    return new AliasListCommand();
	}
	
	@Override
	public Command visitShowHideCmd(
	        UserCommandParser.ShowHideCmdContext ctx) {
	    if (ctx.OVERDUE() != null) {
            return new ShowHideOverdueCommand(ctx.SHOW() != null);
	    } else {
	        return new ShowHideCompletedCommand(ctx.SHOW() != null);
	    }
	}
	
	@Override
	public Command visitSaveLocationCmd(
	        UserCommandParser.SaveLocationCmdContext ctx) {
	    visit(ctx.string());
	    return new SaveLocationCommand(string);
	};

	//----------------STRING-----------------
	
	@Override
	public Command visitString(UserCommandParser.StringContext ctx) { 
		string = userCommand.substring(ctx.getStart().getStartIndex(),
				                       ctx.getStop().getStopIndex()+1);
		return null;
	}

	//----------------TYPES OF DATETIME----------------- 

	@Override
	public Command visitTimeThenDate(UserCommandParser.TimeThenDateContext ctx) {
		visit(ctx.date());
		visit(ctx.time());
		return null;
	}
	
	@Override
	public Command visitDateThenTime(UserCommandParser.DateThenTimeContext ctx) {
		visit(ctx.date());
		visit(ctx.time());
		return null;
	}

	//----------------TYPES OF DATE---------------------
	
	@Override
	public Command visitToday(UserCommandParser.TodayContext ctx) {
	    dateTime = dateTime.with(LocalDate.now());
		return null;
	}

	@Override
	public Command visitTomorrow(UserCommandParser.TomorrowContext ctx) {
	    dateTime = dateTime.with(LocalDate.now()).plusDays(1);
		return null;
	}

	@Override
	public Command visitDayOfWeek(UserCommandParser.DayOfWeekContext ctx) {
		int dayInt = getDayOfWeekInt(ctx.DAY_OF_WEEK().getText());
		DayOfWeek.of(dayInt);	// check that dayInt is valid
		LocalDate today = LocalDate.now();
		int todayInt = today.getDayOfWeek().getValue();
		int offset;
		if (ctx.NEXT() == null) {
		    // the 1st tuesday after today
		    offset = (dayInt - todayInt + 7 - 1) % 7 + 1;
		} else {
		    // the tuesday of next week
		    offset = dayInt - todayInt + 7;
		}
        dateTime = dateTime.with(today.plusDays(offset));
		return null;
	}

	@Override
	public Command visitFullDate(UserCommandParser.FullDateContext ctx) {
		int day = Integer.parseInt(ctx.INT(0).getText());
		int month = Integer.parseInt(ctx.INT(1).getText());
		int year;
		if (ctx.INT(2) != null) {
		    year = Integer.parseInt(ctx.INT(2).getText());
		} else {
		    year = LocalDate.now().getYear();
		}
		dateTime = dateTime.with(LocalDate.of(year, month, day));
		return null;
	}

	@Override
	public Command visitFullDateWordMonth(
	        UserCommandParser.FullDateWordMonthContext ctx) {
		int day = Integer.parseInt(ctx.INT(0).getText());
		int month = getMonth(ctx.MONTH_NAME());
		int year;
		if (ctx.INT(2) != null) {
		    year = Integer.parseInt(ctx.INT(1).getText());
		} else {
		    year = LocalDate.now().getYear();
		}
		dateTime = dateTime.with(LocalDate.of(year, month, day));
		return null;
    }

	@Override
	public Command visitFullDateWordMonthMonthFirst(
	        UserCommandParser.FullDateWordMonthMonthFirstContext ctx) {
		int day = Integer.parseInt(ctx.INT(0).getText());
		int month = getMonth(ctx.MONTH_NAME());
		int year;
		if (ctx.INT(2) != null) {
		    year = Integer.parseInt(ctx.INT(1).getText());
		} else {
		    year = LocalDate.now().getYear();
		}
		dateTime = dateTime.with(LocalDate.of(year, month, day));
		return null;
    }
	
	// date helper functions
	
	private int getDayOfWeekInt(String dayOfWeek) {
		String day = dayOfWeek.substring(0, 3).toLowerCase();
		String[] days = {"", "mon", "tue", "wed", "thu", "fri", "sat", "sun"};
		for (int i=0; i<days.length; i++) {
			if (days[i].equals(day)) {
				return i;
			}
		}
		assert false; // shouldn't happen
		return 0;
	}
	private int getMonth(TerminalNode terminalNode) {
		String month = terminalNode.getText().substring(0, 3).toLowerCase();
		String[] months = {"", "jan", "feb", "mar", "apr", "may", "jun", "jul",
		        "aug", "sep", "oct", "nov", "dec"};
		for (int i=0; i<months.length; i++) {
			if (months[i].equals(month)) {
				return i;
			}
		}
		assert false; // shouldn't happen
		return 0;
	}

	//----------------TYPES OF TIME------------------------

	@Override
	public Command visitTimeWithoutPeriod(
	        UserCommandParser.TimeWithoutPeriodContext ctx) {
		int hour = Integer.parseInt(ctx.INT(0).getText());
		int minute = ctx.INT(1) == null
		        ? 0 : Integer.parseInt(ctx.INT(1).getText());
		dateTime = dateTime.with(LocalTime.of(hour, minute));
		return null;
	}
    
    @Override
    public Command visitTimeWithPeriod(
            UserCommandParser.TimeWithPeriodContext ctx) {
        int hour = Integer.parseInt(ctx.INT(0).getText());
        hour = process12Hour(hour, ctx.AM() == null);
        int minute = ctx.INT(1) == null
                ? 0 : Integer.parseInt(ctx.INT(1).getText());
		dateTime = dateTime.with(LocalTime.of(hour, minute));
        return null;
    }
    
    // time helper functions
    
    private int process12Hour(int hour, boolean isPm) {
        if ((hour > 12) || (hour <= 0)) {
            throw new DateTimeException(
                    "Invalid time, please use correct 12-hour format: " + hour);
        }
        int offset = isPm ? 12 : 0;
        hour += offset;
        if (hour == 12) {   // those are corner cases
            // 12am
            hour = 0;
        } else if (hour == 24) {
            // 12pm
            hour = 12;
        }
        return hour;
    }
    
    //--------------TYPES OF FILTER-----------------
    
    @Override
    public Command visitKeywordFilter(UserCommandParser.KeywordFilterContext ctx) {
        visit(ctx.string());
        keywords.addAll(Arrays.asList(string.split(" ")));
        return null;
    }

    @Override
    public Command visitTimeRangeFilter(
            UserCommandParser.TimeRangeFilterContext ctx) {
        visit(ctx.time());
        if (ctx.BEFORE() == null) {
            // after command
            filters.add(new TimeFilter(dateTime.toLocalTime(), LocalTime.MAX));
        } else {
            // before command
            filters.add(new TimeFilter(LocalTime.MIN, dateTime.toLocalTime()));
        }
        return null;
    }

    @Override
    public Command visitTimeFilter(UserCommandParser.TimeFilterContext ctx) {
        visit(ctx.time());
        LocalTime time = dateTime.toLocalTime();
        filters.add(new TimeFilter(time.minusMinutes(30),
                                   time.plusMinutes(30)));
        return null;
    }

    @Override 
    public Command visitBetweenTimeFilter(
            UserCommandParser.BetweenTimeFilterContext ctx) {
        visit(ctx.time(0));
        LocalTime start = dateTime.toLocalTime();
        visit(ctx.time(1));
        LocalTime end = dateTime.toLocalTime();
        filters.add(new TimeFilter(start, end));
        return null;
    }

    @Override 
    public Command visitDateRangeFilter(
            UserCommandParser.DateRangeFilterContext ctx) {
        visit(ctx.date());
        if (ctx.BEFORE() == null) {
            // after command
            filters.add(new DateTimeFilter(dateTime.with(LocalTime.MIN),
                                           LocalDateTime.MAX));
        } else {
            // before command
            filters.add(new DateTimeFilter(LocalDateTime.MIN,
                                           dateTime.with(LocalTime.MAX)));
        }
        return null;
    }

    @Override
    public Command visitDateFilter(UserCommandParser.DateFilterContext ctx) {
        visit(ctx.date());
        filters.add(new DateTimeFilter(dateTime.with(LocalTime.MIN),
                                   dateTime.with(LocalTime.MAX)));
        return null;
    }

    @Override
    public Command visitBetweenDateFilter(
            UserCommandParser.BetweenDateFilterContext ctx) {
        visit(ctx.date(0));
        LocalDateTime start = dateTime.with(LocalTime.MIN);
        visit(ctx.date(1));
        LocalDateTime end = dateTime.with(LocalTime.MAX);
        filters.add(new DateTimeFilter(start, end));
        return null;
    }

    @Override
    public Command visitDateTimeRangeFilter(
            UserCommandParser.DateTimeRangeFilterContext ctx) {
        visit(ctx.datetime());
        if (ctx.BEFORE() == null) {
            // after command
            filters.add(new DateTimeFilter(dateTime, LocalDateTime.MAX));
        } else {
            // before command
            filters.add(new DateTimeFilter(LocalDateTime.MIN, dateTime));
        }
        return null;
    }

    @Override
    public Command visitBetweenDateTimeFilter(
            UserCommandParser.BetweenDateTimeFilterContext ctx) {
        visit(ctx.datetime(0));
        LocalDateTime start = dateTime;
        visit(ctx.datetime(1));
        LocalDateTime end = dateTime;
        filters.add(new DateTimeFilter(start, end));
        return null;
    }

    @Override
    public Command visitThisWeekFilter(
            UserCommandParser.ThisWeekFilterContext ctx) {
        LocalDateTime now = LocalDateTime.now();
        filters.add(
            new DateTimeFilter(now.with(DayOfWeek.MONDAY).with(LocalTime.MIN),
                               now.with(DayOfWeek.SUNDAY).with(LocalTime.MAX)));
        return null;
    }

    @Override
    public Command visitNextWeekFilter(
            UserCommandParser.NextWeekFilterContext ctx) {
        LocalDateTime nextWeek = LocalDateTime.now().plusWeeks(1);
        filters.add(
            new DateTimeFilter(nextWeek.with(DayOfWeek.MONDAY).with(LocalTime.MIN),
                               nextWeek.with(DayOfWeek.SUNDAY).with(LocalTime.MAX)));
        return null;
    }

    @Override
    public Command visitThisMonthFilter(
            UserCommandParser.ThisMonthFilterContext ctx) {
        LocalDateTime now = LocalDateTime.now();
        filters.add(
            new DateTimeFilter(now.withDayOfMonth(1).with(LocalTime.MIN),
                               now.withDayOfMonth(1).plusMonths(1)
                                   .minusDays(1).with(LocalTime.MAX)));
        return null;
    }

    @Override
    public Command visitNextMonthFilter(
            UserCommandParser.NextMonthFilterContext ctx) {
        LocalDateTime nextMonth = LocalDateTime.now().plusMonths(1);
        filters.add(
            new DateTimeFilter(nextMonth.withDayOfMonth(1).with(LocalTime.MIN),
                               nextMonth.withDayOfMonth(1).plusMonths(1)
                                   .minusDays(1).with(LocalTime.MAX)));
        return null;
    }
    
    @Override
    public Command visitOverdueFilter(OverdueFilterContext ctx) {
        filters.add(new OverdueFilter());
        return null;
    }
	
}
```
###### ./src/main/java/cs2103/v15_1j/jimjim/parser/JJParser.java
``` java
package cs2103.v15_1j.jimjim.parser;

import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.antlr.v4.runtime.*;
import org.antlr.v4.runtime.tree.*;
import cs2103.v15_1j.jimjim.antlr4.*;
import cs2103.v15_1j.jimjim.command.Command;
import cs2103.v15_1j.jimjim.command.InvalidCommand;

public class JJParser implements Parser {

    private static final Logger logger = Logger.getLogger(JJParser.class.getName());
    private Map<String, Integer> aliases = null;
    
    @Override
    public void setAliases(Map<String, Integer> aliases) {
        this.aliases = aliases;
    }

    @Override
    public Command parse(String userCommand) {
        assert userCommand != null;
        logger.entering("JJParser", "parse", userCommand);
        UserCommandLexer lexer =
                new UserCommandLexer(new ANTLRInputStream(userCommand));
        lexer.setAliases(aliases);
        UserCommandParser parser =
                new UserCommandParser(new CommonTokenStream(lexer));
        ParseTree tree = parser.cmd();
        JJCommandVisitor visitor = new JJCommandVisitor(userCommand);
        try {
            return visitor.visit(tree);
        } catch (RuntimeException e) {
            logger.log(Level.INFO, "Exception parsing \"{0}\": {1}", new Object[] { userCommand, e });
            if (e.getMessage() == null) {
                return new InvalidCommand("This feature is not yet implemented.");
            } else {
                return new InvalidCommand(e.getMessage());
            }
        }
    }
    
    @Override
    public String getKeywordString(int keywordInt) {
        return UserCommandLexer.VOCABULARY.getDisplayName(keywordInt).toLowerCase();
    }

}
```
###### ./src/test/java/cs2103/v15_1j/jimjim/parser/JJParserAliasTest.java
``` java
package cs2103.v15_1j.jimjim.parser;

import static org.junit.Assert.*;

import java.util.HashMap;

import org.junit.Before;
import org.junit.Test;

import cs2103.v15_1j.jimjim.antlr4.UserCommandLexer;
import cs2103.v15_1j.jimjim.command.Command;
import cs2103.v15_1j.jimjim.command.DeleteCommand;

public class JJParserAliasTest {
    
    private JJParser parser;
    private HashMap<String, Integer> aliases;

    @Before
    public void setUp() throws Exception {
        aliases = new HashMap<>();
        aliases.put("del", UserCommandLexer.DELETE);
        parser = new JJParser();
        parser.setAliases(aliases);
    }

    @Test
    public void test() {
        Command result = this.parser.parse("DEL d8");
        assertEquals(true, result instanceof DeleteCommand);
        DeleteCommand casted = (DeleteCommand) result;
        assertEquals(8, casted.getTaskNum());
        assertEquals('d', casted.getPrefix());
    }

}
```
###### ./src/test/java/cs2103/v15_1j/jimjim/parser/JJParserCommandTest.java
``` java
package cs2103.v15_1j.jimjim.parser;

import static org.junit.Assert.*;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;

import org.junit.Before;
import org.junit.Test;

import cs2103.v15_1j.jimjim.antlr4.UserCommandLexer;
import cs2103.v15_1j.jimjim.command.*;
import cs2103.v15_1j.jimjim.model.DeadlineTask;
import cs2103.v15_1j.jimjim.model.Event;
import cs2103.v15_1j.jimjim.model.FloatingTask;
import cs2103.v15_1j.jimjim.model.TaskEvent;
import cs2103.v15_1j.jimjim.parser.JJParser;
import cs2103.v15_1j.jimjim.searcher.DateTimeFilter;
import cs2103.v15_1j.jimjim.searcher.Filter;
import cs2103.v15_1j.jimjim.searcher.KeywordFilter;
import cs2103.v15_1j.jimjim.searcher.TimeFilter;

public class JJParserCommandTest {

	JJParser parser;

	@Before
	public void setUp() throws Exception {
		this.parser = new JJParser();
	}

	@Test
	public void testAddFloatingTask() {
		Command result = parser.parse("Learn 10 new words every day");
		assertEquals(true, result instanceof AddCommand);
		AddCommand casted = (AddCommand) result;
		TaskEvent taskEvent = casted.getTaskEvent();
		assertEquals("Learn 10 new words every day", taskEvent.getName());
		assertTrue(taskEvent instanceof FloatingTask);
		FloatingTask castedTask = (FloatingTask) taskEvent;
		assertTrue(!castedTask.getCompleted());
	}
	
	@Test
	public void testAddDeadlineTask() {
		Command result = parser.parse("Submit assignment 2 by 31/12/2016");
		assertEquals(true, result instanceof AddCommand);
		AddCommand casted = (AddCommand) result;
		TaskEvent taskEvent = casted.getTaskEvent();
		assertTrue(taskEvent instanceof DeadlineTask);
		DeadlineTask deadlineTask = (DeadlineTask) taskEvent;
		assertEquals("Submit assignment 2", deadlineTask.getName());
		LocalDateTime resultDateTime = deadlineTask.getDateTime();
		assertEquals(LocalDate.of(2016, 12, 31), resultDateTime.toLocalDate());
		assertEquals(LocalTime.MAX, resultDateTime.toLocalTime());
	}

	@Test
	public void testAddEventCommonDate() {
		Command result = parser.parse(
		        "Group meeting on 20 Feb 1:30 pm to 3 pm");
		assertEquals(true, result instanceof AddCommand);
		AddCommand casted = (AddCommand) result;
		TaskEvent taskEvent = casted.getTaskEvent();
		assertTrue(taskEvent instanceof Event);
		Event event = (Event) taskEvent;
		assertEquals("Group meeting", event.getName());
		assertEquals(LocalDate.of(2016, 2, 20), event.getStartDateTime().toLocalDate());
		assertEquals(LocalTime.of(13, 30), event.getStartDateTime().toLocalTime());
		assertEquals(LocalDate.of(2016, 2, 20), event.getEndDateTime().toLocalDate());
		assertEquals(LocalTime.of(15, 00), event.getEndDateTime().toLocalTime());

		result = parser.parse(
		        "Group meeting from 1:30 pm to 3 pm");
		assertEquals(true, result instanceof AddCommand);
		casted = (AddCommand) result;
		taskEvent = casted.getTaskEvent();
		assertTrue(taskEvent instanceof Event);
		event = (Event) taskEvent;
		assertEquals("Group meeting", event.getName());
		LocalDate today = LocalDate.now();
		assertEquals(today, event.getStartDateTime().toLocalDate());
		assertEquals(LocalTime.of(13, 30), event.getStartDateTime().toLocalTime());
		assertEquals(today, event.getEndDateTime().toLocalDate());
		assertEquals(LocalTime.of(15, 00), event.getEndDateTime().toLocalTime());
	}

	@Test
	public void testAddEventMissingEndDate() {
		Command result = parser.parse(
		        "Group meeting from 20 Feb 1:30 pm to 3 pm");
		assertEquals(true, result instanceof AddCommand);
		AddCommand casted = (AddCommand) result;
		TaskEvent taskEvent = casted.getTaskEvent();
		assertTrue(taskEvent instanceof Event);
		Event event = (Event) taskEvent;
		assertEquals("Group meeting", event.getName());
		assertEquals(LocalDate.of(2016, 2, 20), event.getStartDateTime().toLocalDate());
		assertEquals(LocalTime.of(13, 30), event.getStartDateTime().toLocalTime());
		assertEquals(LocalDate.of(2016, 2, 20), event.getEndDateTime().toLocalDate());
		assertEquals(LocalTime.of(15, 00), event.getEndDateTime().toLocalTime());
	}

	@Test
	public void testAddEventWithoutEndTime() {
		Command result = parser.parse(
		        "Camping with friends at 9.00 am June 1 2016");
		assertEquals(true, result instanceof AddCommand);
		AddCommand casted = (AddCommand) result;
		TaskEvent taskEvent = casted.getTaskEvent();
		assertTrue(taskEvent instanceof Event);
		Event event = (Event) taskEvent;
		assertEquals("Camping with friends", event.getName());
		assertEquals(LocalDate.of(2016, 6, 1), event.getStartDateTime().toLocalDate());
		assertEquals(LocalTime.of(9, 00), event.getStartDateTime().toLocalTime());
		assertEquals(LocalDate.of(2016, 6, 1), event.getEndDateTime().toLocalDate());
		assertEquals(LocalTime.of(10, 00), event.getEndDateTime().toLocalTime());
	}

	@Test
	public void testAddEventDiffDate() {
		Command result = parser.parse(
		        "Camping with friends from June 1 2016 9:00 am to June 3 5:00 pm");
		assertEquals(true, result instanceof AddCommand);
		AddCommand casted = (AddCommand) result;
		TaskEvent taskEvent = casted.getTaskEvent();
		assertTrue(taskEvent instanceof Event);
		Event event = (Event) taskEvent;
		assertEquals("Camping with friends", event.getName());
		assertEquals(LocalDate.of(2016, 6, 1), event.getStartDateTime().toLocalDate());
		assertEquals(LocalTime.of(9, 00), event.getStartDateTime().toLocalTime());
		assertEquals(LocalDate.of(2016, 6, 3), event.getEndDateTime().toLocalDate());
		assertEquals(LocalTime.of(17, 00), event.getEndDateTime().toLocalTime());
	}
	
	@Test
	public void testInvalidEventEndingTime() {
		Command result = parser.parse(
		        "Group meeting on 20 Feb 1:30 pm to 1 pm");
		assertEquals(true, result instanceof InvalidCommand);
		InvalidCommand casted = (InvalidCommand) result;
		assertEquals("Please ensure that the event's"
		            + " ending time is after its starting time", casted.getMessage());

		result = parser.parse(
		        "Camping with friends from June 1 2016 9:00 am to May 3 5:00 pm");
		assertEquals(true, result instanceof InvalidCommand);
		casted = (InvalidCommand) result;
		assertEquals("Please ensure that the event's"
		            + " ending time is after its starting time", casted.getMessage());

		result = parser.parse(
		        "Group meeting from 20 Feb 1:30 pm to 1 pm");
		assertEquals(true, result instanceof InvalidCommand);
		casted = (InvalidCommand) result;
		assertEquals("Please ensure that the event's"
		            + " ending time is after its starting time", casted.getMessage());
	}

    @Test
    public void testDel() {
        Command result = this.parser.parse("DELETE d8");
        assertEquals(true, result instanceof DeleteCommand);
        DeleteCommand casted = (DeleteCommand) result;
        assertEquals(8, casted.getTaskNum());
        assertEquals('d', casted.getPrefix());

        result = this.parser.parse("delete F10");
        assertEquals(true, result instanceof DeleteCommand);
        casted = (DeleteCommand) result;
        assertEquals(10, casted.getTaskNum());
        assertEquals('f', casted.getPrefix());
        
        result = this.parser.parse("delete e8");
        assertEquals(true, result instanceof DeleteCommand);
        casted = (DeleteCommand) result;
        assertEquals(8, casted.getTaskNum());
        assertEquals('e', casted.getPrefix());
    }
    
    @Test
    public void testUnmark() {
        Command result = this.parser.parse("unmark d3");
        assertEquals(true, result instanceof UnmarkCommand);
        UnmarkCommand casted = (UnmarkCommand) result;
        assertEquals(3, casted.getTaskNum());
        assertEquals('d', casted.getPrefix());

        result = this.parser.parse("UNMark F3");
        assertEquals(true, result instanceof UnmarkCommand);
        casted = (UnmarkCommand) result;
        assertEquals(3, casted.getTaskNum());
        assertEquals('f', casted.getPrefix());

        result = this.parser.parse("UNMark e3");
        assertEquals(true, result instanceof UnmarkCommand);
        casted = (UnmarkCommand) result;
        assertEquals(3, casted.getTaskNum());
        assertEquals('e', casted.getPrefix());
    }

    @Test
    public void testMarkDone() {
        Command result = this.parser.parse("mark d3 as done");
        assertEquals(true, result instanceof MarkDoneCommand);
        MarkDoneCommand casted = (MarkDoneCommand) result;
        assertEquals(3, casted.getTaskNum());
        assertEquals('d', casted.getPrefix());

        result = this.parser.parse("Mark F3");
        assertEquals(true, result instanceof MarkDoneCommand);
        casted = (MarkDoneCommand) result;
        assertEquals(3, casted.getTaskNum());
        assertEquals('f', casted.getPrefix());

        result = this.parser.parse("Mark e3");
        assertEquals(true, result instanceof MarkDoneCommand);
        casted = (MarkDoneCommand) result;
        assertEquals(3, casted.getTaskNum());
        assertEquals('e', casted.getPrefix());
    }

    @Test
    public void testSearchOneFilter() {
        Command result = this.parser.parse("search pretty flowers");
        assertTrue(result instanceof SearchCommand);
        SearchCommand casted = (SearchCommand) result;
        assertEquals(1, casted.getFilters().size());
        Filter filter = casted.getFilters().get(0);
        assertTrue(filter instanceof KeywordFilter);
        KeywordFilter castedFilter = (KeywordFilter) filter;
        assertEquals(2, castedFilter.getKeywords().size());
        assertEquals("pretty", castedFilter.getKeywords().get(0));
        assertEquals("flowers", castedFilter.getKeywords().get(1));

        result = this.parser.parse("SEARCH CONTAINS pretty flowers");
        assertTrue(result instanceof SearchCommand);
        casted = (SearchCommand) result;
        assertEquals(1, casted.getFilters().size());
        filter = casted.getFilters().get(0);
        assertTrue(filter instanceof KeywordFilter);
        castedFilter = (KeywordFilter) filter;
        assertEquals(2, castedFilter.getKeywords().size());
        assertEquals("pretty", castedFilter.getKeywords().get(0));
        assertEquals("flowers", castedFilter.getKeywords().get(1));

        result = this.parser.parse("SEARCH contain pretty flowers");
        assertTrue(result instanceof SearchCommand);
        casted = (SearchCommand) result;
        assertEquals(1, casted.getFilters().size());
        filter = casted.getFilters().get(0);
        assertTrue(filter instanceof KeywordFilter);
        castedFilter = (KeywordFilter) filter;
        assertEquals(2, castedFilter.getKeywords().size());
        assertEquals("pretty", castedFilter.getKeywords().get(0));
        assertEquals("flowers", castedFilter.getKeywords().get(1));
    }

    @Test
    public void testSearchManyFilters() {
        Command result = this.parser.parse("search pretty flowers, tomorrow, after 10");
        assertTrue(result instanceof SearchCommand);
        SearchCommand casted = (SearchCommand) result;
        assertEquals(3, casted.getFilters().size());

        Filter filter = casted.getFilters().get(0);
        assertTrue(filter instanceof DateTimeFilter);
        DateTimeFilter dateTimeFilter = (DateTimeFilter) filter;
        LocalDate tomorrow = LocalDate.now().plusDays(1);
        assertEquals(tomorrow.atTime(LocalTime.MIN), dateTimeFilter.getStart());
        assertEquals(tomorrow.atTime(LocalTime.MAX), dateTimeFilter.getEnd());

        filter = casted.getFilters().get(1);
        assertTrue(filter instanceof TimeFilter);
        TimeFilter timeFilter = (TimeFilter) filter;
        assertEquals(LocalTime.of(10, 0), timeFilter.getStart());
        assertEquals(LocalTime.MAX, timeFilter.getEnd());

        filter = casted.getFilters().get(2);
        assertTrue(filter instanceof KeywordFilter);
        KeywordFilter keywordFilter = (KeywordFilter) filter;
        assertEquals(2, keywordFilter.getKeywords().size());
        assertEquals("pretty", keywordFilter.getKeywords().get(0));
        assertEquals("flowers", keywordFilter.getKeywords().get(1));
    }

    @Test
    public void testHideSearch() {
        Command result = this.parser.parse("HIDe sEaRCH");
        assertEquals(true, result instanceof HideSearchCommand);
    }

    @Test
    public void testUndo() {
        Command result = this.parser.parse("undo");
        assertEquals(true, result instanceof UndoCommand);
    }

    @Test
    public void testRedo() {
        Command result = this.parser.parse("Redo");
        assertEquals(true, result instanceof RedoCommand);
    }

    @Test
    public void testHelp() {
        Command result = this.parser.parse("help");
        assertEquals(true, result instanceof HelpCommand);
        HelpCommand casted = (HelpCommand) result;
        assertEquals("index", casted.getPage());

        result = this.parser.parse("help DELETE");
        assertEquals(true, result instanceof HelpCommand);
        casted = (HelpCommand) result;
        assertEquals("delete", casted.getPage());
    }

    @Test
    public void testRename() {
        Command result = this.parser.parse("Rename d8 happy birthday");
        assertEquals(true, result instanceof ChangeCommand);
        ChangeCommand casted = (ChangeCommand) result;
        assertEquals(8, casted.getTaskNum());
        assertEquals('d', casted.getPrefix());
        assertEquals("happy birthday", casted.getNewName());

        result = this.parser.parse("CHANGE F10 TO happy birthday");
        assertEquals(true, result instanceof ChangeCommand);
        casted = (ChangeCommand) result;
        assertEquals(10, casted.getTaskNum());
        assertEquals('f', casted.getPrefix());
        assertEquals("happy birthday", casted.getNewName());
    }

    @Test
    public void testChangeOtherKeyword() {
        Command result = this.parser.parse("SHIFT e8 21st April 2016");
        assertEquals(true, result instanceof ShiftCommand);
        ShiftCommand shift = (ShiftCommand) result;
        assertEquals(8, shift.getTaskNum());
        assertEquals('e', shift.getPrefix());
        assertEquals(LocalDate.of(2016, 4, 21), shift.getNewDate());

        result = this.parser.parse("ReschedUle D10 TO 5.30pm");
        assertEquals(true, result instanceof ChangeCommand);
        ChangeCommand casted = (ChangeCommand) result;
        assertEquals(10, casted.getTaskNum());
        assertEquals('d', casted.getPrefix());
        assertEquals(LocalTime.of(17, 30), casted.getNewStartTime());

        result = this.parser.parse("extend e8 to 3:00pm 5/4/2016");
        assertEquals(true, result instanceof ChangeCommand);
        casted = (ChangeCommand) result;
        assertEquals(8, casted.getTaskNum());
        assertEquals('e', casted.getPrefix());
        assertEquals(LocalDate.of(2016, 4, 5), casted.getNewEndDate());
        assertEquals(LocalTime.of(15, 0), casted.getNewEndTime());
    }

    @Test
    public void testExtend() {
        Command result = this.parser.parse("Extend e8 21st April 2016");
        assertEquals(true, result instanceof ChangeCommand);
        ChangeCommand casted = (ChangeCommand) result;
        assertEquals(8, casted.getTaskNum());
        assertEquals('e', casted.getPrefix());
        assertEquals(LocalDate.of(2016, 4, 21), casted.getNewEndDate());

        result = this.parser.parse("EXTEND E10 TO 5.30pm");
        assertEquals(true, result instanceof ChangeCommand);
        casted = (ChangeCommand) result;
        assertEquals(10, casted.getTaskNum());
        assertEquals('e', casted.getPrefix());
        assertEquals(LocalTime.of(17, 30), casted.getNewEndTime());

        result = this.parser.parse("Extend e8 to 3:00pm 5/4/2016");
        assertEquals(true, result instanceof ChangeCommand);
        casted = (ChangeCommand) result;
        assertEquals(8, casted.getTaskNum());
        assertEquals('e', casted.getPrefix());
        assertEquals(LocalDate.of(2016, 4, 5), casted.getNewEndDate());
        assertEquals(LocalTime.of(15, 0), casted.getNewEndTime());
    }
    
    @Test
    public void testAliasAdd() {
        Command result = this.parser.parse("ALIas adD dElEtE DEL");
        assertEquals(true, result instanceof AliasAddCommand);
        AliasAddCommand casted = (AliasAddCommand) result;
        assertEquals("del", casted.getAlias());
        assertEquals("dElEtE", casted.getKeywordString());
        assertEquals(UserCommandLexer.DELETE, casted.getKeyword());
    }

    @Test
    public void testAliasAddInvalid() {
        Command result = this.parser.parse("ALIas adD MARK DELete");
        assertEquals(true, result instanceof InvalidCommand);
        InvalidCommand casted = (InvalidCommand) result;
        assertEquals("\"DELete\" is already a keyword and cannot be made an alias!",
                casted.getMessage());
    }
    
    @Test
    public void testAliasDelete() {
        Command result = this.parser.parse("ALIas dElEtE DeL");
        assertEquals(true, result instanceof AliasDeleteCommand);
        AliasDeleteCommand casted = (AliasDeleteCommand) result;
        assertEquals("del", casted.getAlias());
    }

    @Test
    public void testAliasList() {
        Command result = this.parser.parse("ALIas LiSt");
        assertEquals(true, result instanceof AliasListCommand);
        result = this.parser.parse("ALIas shoW");
        assertEquals(true, result instanceof AliasListCommand);
    }

    public void testShowHideOverdue() {
        Command result = this.parser.parse("show overdue");
        assertEquals(true, result instanceof ShowHideOverdueCommand);
        assertTrue(((ShowHideOverdueCommand)result).getWillShow());
        result = this.parser.parse("hide Overdue");
        assertEquals(true, result instanceof ShowHideOverdueCommand);
        assertFalse(((ShowHideOverdueCommand)result).getWillShow());
    }

    public void testShowHideCompleted() {
        Command result = this.parser.parse("show COMPLETED");
        assertEquals(true, result instanceof ShowHideCompletedCommand);
        assertTrue(((ShowHideCompletedCommand)result).getWillShow());
        result = this.parser.parse("hide Done");
        assertEquals(true, result instanceof ShowHideCompletedCommand);
        assertFalse(((ShowHideCompletedCommand)result).getWillShow());
    }
    
    public void testSaveLocation() {
        Command result = this.parser.parse("sAvE to save/data.json");
        assertTrue(result instanceof SaveLocationCommand);
        SaveLocationCommand casted = (SaveLocationCommand) result;
        assertEquals("save/data.json", casted.getSavePath());
    }
}
```
###### ./src/test/java/cs2103/v15_1j/jimjim/parser/JJParserDateTimeTest.java
``` java
package cs2103.v15_1j.jimjim.parser;

import static org.junit.Assert.*;

import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;

import org.junit.Before;
import org.junit.Test;

import cs2103.v15_1j.jimjim.command.AddCommand;
import cs2103.v15_1j.jimjim.command.Command;
import cs2103.v15_1j.jimjim.command.InvalidCommand;
import cs2103.v15_1j.jimjim.model.DeadlineTask;
import cs2103.v15_1j.jimjim.model.TaskEvent;
import cs2103.v15_1j.jimjim.parser.JJParser;

public class JJParserDateTimeTest {
	JJParser parser;

	@Before
	public void setUp() throws Exception {
		this.parser = new JJParser();
	}

	@Test
	public void testHour() {
		Command result = parser.parse("Go to sleep by 11");
		assertEquals(true, result instanceof AddCommand);
		AddCommand casted = (AddCommand) result;
		TaskEvent taskEvent = casted.getTaskEvent();
		assertTrue(taskEvent instanceof DeadlineTask);
		DeadlineTask deadlineTask = (DeadlineTask) taskEvent;
		assertEquals("Go to sleep", deadlineTask.getName());
		LocalDateTime now = LocalDateTime.now();
		LocalDateTime resultDateTime = deadlineTask.getDateTime();
		assertEquals(now.toLocalDate(), resultDateTime.toLocalDate());
		assertEquals(LocalTime.of(11, 0), resultDateTime.toLocalTime());

		result = parser.parse("Go to sleep by 11 o'clock");
		assertEquals(true, result instanceof AddCommand);
		casted = (AddCommand) result;
		taskEvent = casted.getTaskEvent();
		assertTrue(taskEvent instanceof DeadlineTask);
		deadlineTask = (DeadlineTask) taskEvent;
		assertEquals("Go to sleep", deadlineTask.getName());
		now = LocalDateTime.now();
		resultDateTime = deadlineTask.getDateTime();
		assertEquals(now.toLocalDate(), resultDateTime.toLocalDate());
		assertEquals(LocalTime.of(11, 0), resultDateTime.toLocalTime());
	}

	@Test
	public void testInvalidHour() {
		Command result = parser.parse("Go to sleep by 25");
		assertEquals(true, result instanceof InvalidCommand);
		InvalidCommand casted = (InvalidCommand) result;
		assertEquals("Invalid value for HourOfDay (valid values 0 - 23): 25",
				casted.getMessage());
	}
	
	@Test
	public void testHourMinute() {
		Command result = parser.parse("Go to bed by 11.30");
		assertEquals(true, result instanceof AddCommand);
		AddCommand casted = (AddCommand) result;
		TaskEvent taskEvent = casted.getTaskEvent();
		assertTrue(taskEvent instanceof DeadlineTask);
		DeadlineTask deadlineTask = (DeadlineTask) taskEvent;
		assertEquals("Go to bed", deadlineTask.getName());
		LocalDateTime now = LocalDateTime.now();
		LocalDateTime resultDateTime = deadlineTask.getDateTime();
		assertEquals(now.toLocalDate(), resultDateTime.toLocalDate());
		assertEquals(LocalTime.of(11, 30), resultDateTime.toLocalTime());
	}
	
	@Test
	public void testTodayTomorrow() {
		Command result = parser.parse("Finish CS2106 homework by today");
		assertEquals(true, result instanceof AddCommand);
		AddCommand casted = (AddCommand) result;
		TaskEvent taskEvent = casted.getTaskEvent();
		assertTrue(taskEvent instanceof DeadlineTask);
		DeadlineTask deadlineTask = (DeadlineTask) taskEvent;
		assertEquals("Finish CS2106 homework", deadlineTask.getName());
		LocalDateTime now = LocalDateTime.now();
		LocalDateTime resultDateTime = deadlineTask.getDateTime();
		assertEquals(now.toLocalDate(), resultDateTime.toLocalDate());
		assertEquals(LocalTime.MAX, resultDateTime.toLocalTime());
		
		result = parser.parse("Finish CS2106 homework by tomorrow");
		assertEquals(true, result instanceof AddCommand);
		casted = (AddCommand) result;
		taskEvent = casted.getTaskEvent();
		assertTrue(taskEvent instanceof DeadlineTask);
		deadlineTask = (DeadlineTask) taskEvent;
		assertEquals("Finish CS2106 homework", deadlineTask.getName());
		resultDateTime = deadlineTask.getDateTime();
		assertEquals(now.toLocalDate().plusDays(1), resultDateTime.toLocalDate());
		assertEquals(LocalTime.MAX, resultDateTime.toLocalTime());
	}
	
	@Test
	public void testDateDayOfWeek() {
		Command result = parser.parse("Submit assignment 2 by Sunday");
		assertEquals(true, result instanceof AddCommand);
		AddCommand casted = (AddCommand) result;
		TaskEvent taskEvent = casted.getTaskEvent();
		assertTrue(taskEvent instanceof DeadlineTask);
		DeadlineTask deadlineTask = (DeadlineTask) taskEvent;
		assertEquals("Submit assignment 2", deadlineTask.getName());
		LocalDateTime now = LocalDateTime.now();
		LocalDateTime resultDateTime = deadlineTask.getDateTime();
		// ensure it's first sunday after today
		assertEquals(DayOfWeek.SUNDAY, resultDateTime.getDayOfWeek());
		assertEquals(true, resultDateTime.isAfter(now));
		assertTrue(resultDateTime.toLocalDate().minusDays(8)
		        .isBefore(now.toLocalDate()));
		assertEquals(LocalTime.MAX, resultDateTime.toLocalTime());
		
		result = parser.parse("Submit assignment 2 by THIS mon");
		assertEquals(true, result instanceof AddCommand);
		casted = (AddCommand) result;
		taskEvent = casted.getTaskEvent();
		assertTrue(taskEvent instanceof DeadlineTask);
		deadlineTask = (DeadlineTask) taskEvent;
		assertEquals("Submit assignment 2", deadlineTask.getName());
		resultDateTime = deadlineTask.getDateTime();
		// ensure it's first monday after today
		assertEquals(DayOfWeek.MONDAY, resultDateTime.getDayOfWeek());
		assertEquals(true, resultDateTime.isAfter(now));
		assertTrue(resultDateTime.toLocalDate().minusDays(8)
		        .isBefore(now.toLocalDate()));
		assertEquals(LocalTime.MAX, resultDateTime.toLocalTime());

		result = parser.parse("Submit assignment 2 by next mon");
		assertEquals(true, result instanceof AddCommand);
		casted = (AddCommand) result;
		taskEvent = casted.getTaskEvent();
		assertTrue(taskEvent instanceof DeadlineTask);
		deadlineTask = (DeadlineTask) taskEvent;
		assertEquals("Submit assignment 2", deadlineTask.getName());
		resultDateTime = deadlineTask.getDateTime();
		// ensure it's monday of next week
		assertEquals(DayOfWeek.MONDAY, resultDateTime.getDayOfWeek());
		assertEquals(true, resultDateTime.isAfter(now));
		assertEquals(true, resultDateTime.toLocalDate().minusDays(8)
		        .isBefore(now.toLocalDate()));
		assertEquals(LocalTime.MAX, resultDateTime.toLocalTime());

		result = parser.parse("Submit assignment 2 by next SUNDAy");
		assertEquals(true, result instanceof AddCommand);
		casted = (AddCommand) result;
		taskEvent = casted.getTaskEvent();
		assertTrue(taskEvent instanceof DeadlineTask);
		deadlineTask = (DeadlineTask) taskEvent;
		assertEquals("Submit assignment 2", deadlineTask.getName());
		resultDateTime = deadlineTask.getDateTime();
		// ensure it's sunday of next week
		System.out.println(resultDateTime);
		assertEquals(DayOfWeek.SUNDAY, resultDateTime.getDayOfWeek());
		assertEquals(true, resultDateTime.toLocalDate().minusDays(14)
		        .isBefore(now.toLocalDate()));
		assertEquals(true, resultDateTime.toLocalDate().minusDays(6)
		        .isAfter(now.toLocalDate()));
		assertEquals(LocalTime.MAX, resultDateTime.toLocalTime());
	}
	
	@Test
	public void testFullDate() {
		Command result = parser.parse("Submit assignment 2 by 31/12/2016");
		assertEquals(true, result instanceof AddCommand);
		AddCommand casted = (AddCommand) result;
		TaskEvent taskEvent = casted.getTaskEvent();
		assertTrue(taskEvent instanceof DeadlineTask);
		DeadlineTask deadlineTask = (DeadlineTask) taskEvent;
		assertEquals("Submit assignment 2", deadlineTask.getName());
		LocalDateTime resultDateTime = deadlineTask.getDateTime();
		assertEquals(LocalDate.of(2016, 12, 31), resultDateTime.toLocalDate());
		assertEquals(LocalTime.MAX, resultDateTime.toLocalTime());
	}
	
	@Test
	public void testInvalidFullDate() {
		Command result = parser.parse("Submit assignment 2 by 31/11/2016");
		assertEquals(true, result instanceof InvalidCommand);
		InvalidCommand casted = (InvalidCommand) result;
		assertEquals("Invalid date 'NOVEMBER 31'", casted.getMessage());
	}
	
	@Test
	public void testDayMonth() {
		Command result = parser.parse("Submit assignment 2 by 31/12");
		assertEquals(true, result instanceof AddCommand);
		AddCommand casted = (AddCommand) result;
		TaskEvent taskEvent = casted.getTaskEvent();
		assertTrue(taskEvent instanceof DeadlineTask);
		DeadlineTask deadlineTask = (DeadlineTask) taskEvent;
		assertEquals("Submit assignment 2", deadlineTask.getName());
		LocalDateTime resultDateTime = deadlineTask.getDateTime();
		assertEquals(LocalDate.of(LocalDate.now().getYear(), 12, 31), resultDateTime.toLocalDate());
		assertEquals(LocalTime.MAX, resultDateTime.toLocalTime());
	}
	
	@Test
	public void testDateAndTime() {
		Command result = parser.parse("Submit assignment 2 by 17.00 31/12");
		assertEquals(true, result instanceof AddCommand);
		AddCommand casted = (AddCommand) result;
		TaskEvent taskEvent = casted.getTaskEvent();
		assertTrue(taskEvent instanceof DeadlineTask);
		DeadlineTask deadlineTask = (DeadlineTask) taskEvent;
		assertEquals("Submit assignment 2", deadlineTask.getName());
		LocalDateTime resultDateTime = deadlineTask.getDateTime();
		assertEquals(LocalDate.of(LocalDate.now().getYear(), 12, 31), resultDateTime.toLocalDate());
		assertEquals(LocalTime.of(17, 00), resultDateTime.toLocalTime());
		
		result = parser.parse("Submit assignment 2 by Friday 14");
		assertEquals(true, result instanceof AddCommand);
		casted = (AddCommand) result;
		taskEvent = casted.getTaskEvent();
		assertTrue(taskEvent instanceof DeadlineTask);
		deadlineTask = (DeadlineTask) taskEvent;
		LocalDateTime now = LocalDateTime.now();
		assertEquals("Submit assignment 2", deadlineTask.getName());
		resultDateTime = deadlineTask.getDateTime();
		assertEquals(DayOfWeek.FRIDAY, resultDateTime.getDayOfWeek());
		assertEquals(true, resultDateTime.isAfter(now));
		assertEquals(LocalTime.of(14, 00), resultDateTime.toLocalTime());
	}

	@Test
	public void test12HourFormat() {
		Command result = parser.parse("Go to sleep by 11 pm");
		assertEquals(true, result instanceof AddCommand);
		AddCommand casted = (AddCommand) result;
		TaskEvent taskEvent = casted.getTaskEvent();
		assertTrue(taskEvent instanceof DeadlineTask);
		DeadlineTask deadlineTask = (DeadlineTask) taskEvent;
		assertEquals("Go to sleep", deadlineTask.getName());
		LocalDateTime now = LocalDateTime.now();
		LocalDateTime resultDateTime = deadlineTask.getDateTime();
		assertEquals(now.toLocalDate(), resultDateTime.toLocalDate());
		assertEquals(LocalTime.of(23, 0), resultDateTime.toLocalTime());

		result = parser.parse("Go to sleep by 11.45 a.m.");
		assertEquals(true, result instanceof AddCommand);
		casted = (AddCommand) result;
		taskEvent = casted.getTaskEvent();
		assertTrue(taskEvent instanceof DeadlineTask);
		deadlineTask = (DeadlineTask) taskEvent;
		assertEquals("Go to sleep", deadlineTask.getName());
		resultDateTime = deadlineTask.getDateTime();
		assertEquals(now.toLocalDate(), resultDateTime.toLocalDate());
		assertEquals(LocalTime.of(11, 45), resultDateTime.toLocalTime());

		result = parser.parse("Go to sleep by 12:45 a.m.");
		assertEquals(true, result instanceof AddCommand);
		casted = (AddCommand) result;
		taskEvent = casted.getTaskEvent();
		assertTrue(taskEvent instanceof DeadlineTask);
		deadlineTask = (DeadlineTask) taskEvent;
		assertEquals("Go to sleep", deadlineTask.getName());
		resultDateTime = deadlineTask.getDateTime();
		assertEquals(now.toLocalDate(), resultDateTime.toLocalDate());
		assertEquals(LocalTime.of(0, 45), resultDateTime.toLocalTime());

		result = parser.parse("Go to sleep by 12:45 pm");
		assertEquals(true, result instanceof AddCommand);
		casted = (AddCommand) result;
		taskEvent = casted.getTaskEvent();
		assertTrue(taskEvent instanceof DeadlineTask);
		deadlineTask = (DeadlineTask) taskEvent;
		assertEquals("Go to sleep", deadlineTask.getName());
		resultDateTime = deadlineTask.getDateTime();
		assertEquals(now.toLocalDate(), resultDateTime.toLocalDate());
		assertEquals(LocalTime.of(12, 45), resultDateTime.toLocalTime());
	}
	
	@Test
	public void testInvalid12HourFormat() {
		Command result = parser.parse("Go to sleep by 13 a.m.");
		assertEquals(true, result instanceof InvalidCommand);
		InvalidCommand casted = (InvalidCommand) result;
		assertEquals("Invalid time, please use correct 12-hour format: 13",
				casted.getMessage());
	}

	@Test
	public void test12HourFormatWithoutSpace() {
		Command result = parser.parse("Go to sleep by 11pm");
		assertEquals(true, result instanceof AddCommand);
		AddCommand casted = (AddCommand) result;
		TaskEvent taskEvent = casted.getTaskEvent();
		assertTrue(taskEvent instanceof DeadlineTask);
		DeadlineTask deadlineTask = (DeadlineTask) taskEvent;
		assertEquals("Go to sleep", deadlineTask.getName());
		LocalDateTime now = LocalDateTime.now();
		LocalDateTime resultDateTime = deadlineTask.getDateTime();
		assertEquals(now.toLocalDate(), resultDateTime.toLocalDate());
		assertEquals(LocalTime.of(23, 0), resultDateTime.toLocalTime());

		result = parser.parse("Go to sleep by 11.45am");
		assertEquals(true, result instanceof AddCommand);
		casted = (AddCommand) result;
		taskEvent = casted.getTaskEvent();
		assertTrue(taskEvent instanceof DeadlineTask);
		deadlineTask = (DeadlineTask) taskEvent;
		assertEquals("Go to sleep", deadlineTask.getName());
		resultDateTime = deadlineTask.getDateTime();
		assertEquals(now.toLocalDate(), resultDateTime.toLocalDate());
		assertEquals(LocalTime.of(11, 45), resultDateTime.toLocalTime());

		result = parser.parse("Go to sleep by 12:45am");
		assertEquals(true, result instanceof AddCommand);
		casted = (AddCommand) result;
		taskEvent = casted.getTaskEvent();
		assertTrue(taskEvent instanceof DeadlineTask);
		deadlineTask = (DeadlineTask) taskEvent;
		assertEquals("Go to sleep", deadlineTask.getName());
		resultDateTime = deadlineTask.getDateTime();
		assertEquals(now.toLocalDate(), resultDateTime.toLocalDate());
		assertEquals(LocalTime.of(0, 45), resultDateTime.toLocalTime());

		result = parser.parse("Go to sleep by 12:45pm");
		assertEquals(true, result instanceof AddCommand);
		casted = (AddCommand) result;
		taskEvent = casted.getTaskEvent();
		assertTrue(taskEvent instanceof DeadlineTask);
		deadlineTask = (DeadlineTask) taskEvent;
		assertEquals("Go to sleep", deadlineTask.getName());
		resultDateTime = deadlineTask.getDateTime();
		assertEquals(now.toLocalDate(), resultDateTime.toLocalDate());
		assertEquals(LocalTime.of(12, 45), resultDateTime.toLocalTime());
	}

	@Test
	public void testFullDateMonthWord() {
		Command result = parser.parse("Submit assignment 2 by 31-May-2016");
		assertEquals(true, result instanceof AddCommand);
		AddCommand casted = (AddCommand) result;
		TaskEvent taskEvent = casted.getTaskEvent();
		assertTrue(taskEvent instanceof DeadlineTask);
		DeadlineTask deadlineTask = (DeadlineTask) taskEvent;
		assertEquals("Submit assignment 2", deadlineTask.getName());
		LocalDateTime resultDateTime = deadlineTask.getDateTime();
		assertEquals(LocalDate.of(2016, 5, 31), resultDateTime.toLocalDate());
		assertEquals(LocalTime.MAX, resultDateTime.toLocalTime());

		result = parser.parse("Submit assignment 2 by 31 DECEMBER, 2016");
		System.out.println();
		assertEquals(true, result instanceof AddCommand);
		casted = (AddCommand) result;
		taskEvent = casted.getTaskEvent();
		assertTrue(taskEvent instanceof DeadlineTask);
		deadlineTask = (DeadlineTask) taskEvent;
		assertEquals("Submit assignment 2", deadlineTask.getName());
		resultDateTime = deadlineTask.getDateTime();
		assertEquals(LocalDate.of(2016, 12, 31), resultDateTime.toLocalDate());
		assertEquals(LocalTime.MAX, resultDateTime.toLocalTime());

		result = parser.parse("Submit assignment 2 by 30 apr");
		assertEquals(true, result instanceof AddCommand);
		casted = (AddCommand) result;
		taskEvent = casted.getTaskEvent();
		assertTrue(taskEvent instanceof DeadlineTask);
		deadlineTask = (DeadlineTask) taskEvent;
		assertEquals("Submit assignment 2", deadlineTask.getName());
		resultDateTime = deadlineTask.getDateTime();
		assertEquals(LocalDate.of(LocalDateTime.now().getYear(), 4, 30),
		        resultDateTime.toLocalDate());
		assertEquals(LocalTime.MAX, resultDateTime.toLocalTime());
	}

	@Test
	public void testFullDateMonthWordMonthFirst() {
		Command result = parser.parse("Submit assignment 2 by FEB/20/2016");
		assertEquals(true, result instanceof AddCommand);
		AddCommand casted = (AddCommand) result;
		TaskEvent taskEvent = casted.getTaskEvent();
		assertTrue(taskEvent instanceof DeadlineTask);
		DeadlineTask deadlineTask = (DeadlineTask) taskEvent;
		assertEquals("Submit assignment 2", deadlineTask.getName());
		LocalDateTime resultDateTime = deadlineTask.getDateTime();
		assertEquals(LocalDate.of(2016, 2, 20), resultDateTime.toLocalDate());
		assertEquals(LocalTime.MAX, resultDateTime.toLocalTime());

		result = parser.parse("Submit assignment 2 by ocToBEr 15, 2016");
		System.out.println();
		assertEquals(true, result instanceof AddCommand);
		casted = (AddCommand) result;
		taskEvent = casted.getTaskEvent();
		assertTrue(taskEvent instanceof DeadlineTask);
		deadlineTask = (DeadlineTask) taskEvent;
		assertEquals("Submit assignment 2", deadlineTask.getName());
		resultDateTime = deadlineTask.getDateTime();
		assertEquals(LocalDate.of(2016, 10, 15), resultDateTime.toLocalDate());
		assertEquals(LocalTime.MAX, resultDateTime.toLocalTime());

		result = parser.parse("Submit assignment 2 by july 4");
		assertEquals(true, result instanceof AddCommand);
		casted = (AddCommand) result;
		taskEvent = casted.getTaskEvent();
		assertTrue(taskEvent instanceof DeadlineTask);
		deadlineTask = (DeadlineTask) taskEvent;
		assertEquals("Submit assignment 2", deadlineTask.getName());
		resultDateTime = deadlineTask.getDateTime();
		assertEquals(LocalDate.of(LocalDateTime.now().getYear(), 7, 4),
		        resultDateTime.toLocalDate());
		assertEquals(LocalTime.MAX, resultDateTime.toLocalTime());
	}

	@Test
	public void testFullDateTimeMonthWord() {
		Command result = parser.parse("Submit assignment 2 by 20 Feb 2016 5 pm");
		assertEquals(true, result instanceof AddCommand);
		AddCommand casted = (AddCommand) result;
		TaskEvent taskEvent = casted.getTaskEvent();
		assertTrue(taskEvent instanceof DeadlineTask);
		DeadlineTask deadlineTask = (DeadlineTask) taskEvent;
		assertEquals("Submit assignment 2", deadlineTask.getName());
		LocalDateTime resultDateTime = deadlineTask.getDateTime();
		assertEquals(LocalDate.of(2016, 2, 20), resultDateTime.toLocalDate());
		assertEquals(LocalTime.of(17, 00), resultDateTime.toLocalTime());

		result = parser.parse("Submit assignment 2 by 11.50 ocToBEr 15, 2016");
		System.out.println();
		assertEquals(true, result instanceof AddCommand);
		casted = (AddCommand) result;
		taskEvent = casted.getTaskEvent();
		assertTrue(taskEvent instanceof DeadlineTask);
		deadlineTask = (DeadlineTask) taskEvent;
		assertEquals("Submit assignment 2", deadlineTask.getName());
		resultDateTime = deadlineTask.getDateTime();
		assertEquals(LocalDate.of(2016, 10, 15), resultDateTime.toLocalDate());
		assertEquals(LocalTime.of(11, 50), resultDateTime.toLocalTime());

		result = parser.parse("Submit assignment 2 by july 4 12.00");
		assertEquals(true, result instanceof AddCommand);
		casted = (AddCommand) result;
		taskEvent = casted.getTaskEvent();
		assertTrue(taskEvent instanceof DeadlineTask);
		deadlineTask = (DeadlineTask) taskEvent;
		assertEquals("Submit assignment 2", deadlineTask.getName());
		resultDateTime = deadlineTask.getDateTime();
		assertEquals(LocalDate.of(LocalDateTime.now().getYear(), 7, 4),
		        resultDateTime.toLocalDate());
		assertEquals(LocalTime.of(12, 0), resultDateTime.toLocalTime());
	}

	@Test
	public void testOrdinalEnding() {
		Command result = parser.parse("Submit assignment 2 by 20th Feb 2016 5 pm");
		assertEquals(true, result instanceof AddCommand);
		AddCommand casted = (AddCommand) result;
		TaskEvent taskEvent = casted.getTaskEvent();
		assertTrue(taskEvent instanceof DeadlineTask);
		DeadlineTask deadlineTask = (DeadlineTask) taskEvent;
		assertEquals("Submit assignment 2", deadlineTask.getName());
		LocalDateTime resultDateTime = deadlineTask.getDateTime();
		assertEquals(LocalDate.of(2016, 2, 20), resultDateTime.toLocalDate());
		assertEquals(LocalTime.of(17, 00), resultDateTime.toLocalTime());

		result = parser.parse("Submit assignment 2 by 11.50 ocToBEr 21st, 2016");
		System.out.println();
		assertEquals(true, result instanceof AddCommand);
		casted = (AddCommand) result;
		taskEvent = casted.getTaskEvent();
		assertTrue(taskEvent instanceof DeadlineTask);
		deadlineTask = (DeadlineTask) taskEvent;
		assertEquals("Submit assignment 2", deadlineTask.getName());
		resultDateTime = deadlineTask.getDateTime();
		assertEquals(LocalDate.of(2016, 10, 21), resultDateTime.toLocalDate());
		assertEquals(LocalTime.of(11, 50), resultDateTime.toLocalTime());

		result = parser.parse("Submit assignment 2 by july 2nd 12.00");
		assertEquals(true, result instanceof AddCommand);
		casted = (AddCommand) result;
		taskEvent = casted.getTaskEvent();
		assertTrue(taskEvent instanceof DeadlineTask);
		deadlineTask = (DeadlineTask) taskEvent;
		assertEquals("Submit assignment 2", deadlineTask.getName());
		resultDateTime = deadlineTask.getDateTime();
		assertEquals(LocalDate.of(LocalDateTime.now().getYear(), 7, 2),
		        resultDateTime.toLocalDate());
		assertEquals(LocalTime.of(12, 0), resultDateTime.toLocalTime());

		result = parser.parse("Submit assignment 2 by july 23rd 12.00");
		assertEquals(true, result instanceof AddCommand);
		casted = (AddCommand) result;
		taskEvent = casted.getTaskEvent();
		assertTrue(taskEvent instanceof DeadlineTask);
		deadlineTask = (DeadlineTask) taskEvent;
		assertEquals("Submit assignment 2", deadlineTask.getName());
		resultDateTime = deadlineTask.getDateTime();
		assertEquals(LocalDate.of(LocalDateTime.now().getYear(), 7, 23),
		        resultDateTime.toLocalDate());
		assertEquals(LocalTime.of(12, 0), resultDateTime.toLocalTime());
	}

}
```
###### ./src/test/java/cs2103/v15_1j/jimjim/parser/JJParserSearchFilterTest.java
``` java
package cs2103.v15_1j.jimjim.parser;

import static org.junit.Assert.*;

import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;

import org.junit.Before;
import org.junit.Test;

import cs2103.v15_1j.jimjim.command.Command;
import cs2103.v15_1j.jimjim.command.SearchCommand;
import cs2103.v15_1j.jimjim.searcher.DateTimeFilter;
import cs2103.v15_1j.jimjim.searcher.Filter;
import cs2103.v15_1j.jimjim.searcher.OverdueFilter;
import cs2103.v15_1j.jimjim.searcher.TimeFilter;

public class JJParserSearchFilterTest {
		
	JJParser parser;

	@Before
	public void setUp() throws Exception {
		this.parser = new JJParser();
	}

    @Test
    public void testTimeOnly() {
        Command result = this.parser.parse("search at 7pm");
        assertTrue(result instanceof SearchCommand);
        SearchCommand casted = (SearchCommand) result;
        assertEquals(1, casted.getFilters().size());
        Filter filter = casted.getFilters().get(0);
        assertTrue(filter instanceof TimeFilter);
        TimeFilter castedFilter = (TimeFilter) filter;
        assertEquals(LocalTime.of(18, 30), castedFilter.getStart());
        assertEquals(LocalTime.of(19, 30), castedFilter.getEnd());
    }
    
    @Test
    public void testTime() {
        Command result = this.parser.parse("search before 7pm");
        assertTrue(result instanceof SearchCommand);
        SearchCommand casted = (SearchCommand) result;
        assertEquals(1, casted.getFilters().size());
        Filter filter = casted.getFilters().get(0);
        assertTrue(filter instanceof TimeFilter);
        TimeFilter castedFilter = (TimeFilter) filter;
        assertEquals(LocalTime.MIN, castedFilter.getStart());
        assertEquals(LocalTime.of(19, 0), castedFilter.getEnd());

        result = this.parser.parse("search after 19.30");
        assertTrue(result instanceof SearchCommand);
        casted = (SearchCommand) result;
        assertEquals(1, casted.getFilters().size());
        filter = casted.getFilters().get(0);
        assertTrue(filter instanceof TimeFilter);
        castedFilter = (TimeFilter) filter;
        assertEquals(LocalTime.of(19, 30), castedFilter.getStart());
        assertEquals(LocalTime.MAX, castedFilter.getEnd());

        result = this.parser.parse("search between 7pm and 7.30pm");
        assertTrue(result instanceof SearchCommand);
        casted = (SearchCommand) result;
        assertEquals(1, casted.getFilters().size());
        filter = casted.getFilters().get(0);
        assertTrue(filter instanceof TimeFilter);
        castedFilter = (TimeFilter) filter;
        assertEquals(LocalTime.of(19, 0), castedFilter.getStart());
        assertEquals(LocalTime.of(19, 30), castedFilter.getEnd());
    }

    @Test
    public void testDateOnly() {
        Command result = this.parser.parse("search 5th April 2016");
        assertTrue(result instanceof SearchCommand);
        SearchCommand casted = (SearchCommand) result;
        assertEquals(1, casted.getFilters().size());
        Filter filter = casted.getFilters().get(0);
        assertTrue(filter instanceof DateTimeFilter);
        DateTimeFilter castedFilter = (DateTimeFilter) filter;
        assertEquals(LocalDateTime.of(LocalDate.of(2016, 4, 5), LocalTime.MIN),
                castedFilter.getStart());
        assertEquals(LocalDateTime.of(LocalDate.of(2016, 4, 5), LocalTime.MAX),
                castedFilter.getEnd());
    }
    
    @Test
    public void testDate() {
        Command result = this.parser.parse("search after 5th April 2016");
        assertTrue(result instanceof SearchCommand);
        SearchCommand casted = (SearchCommand) result;
        assertEquals(1, casted.getFilters().size());
        Filter filter = casted.getFilters().get(0);
        assertTrue(filter instanceof DateTimeFilter);
        DateTimeFilter castedFilter = (DateTimeFilter) filter;
        assertEquals(LocalDateTime.of(LocalDate.of(2016, 4, 5), LocalTime.MIN),
                castedFilter.getStart());
        assertEquals(LocalDateTime.MAX, castedFilter.getEnd());

        result = this.parser.parse("search before 5-4-2016");
        assertTrue(result instanceof SearchCommand);
        casted = (SearchCommand) result;
        assertEquals(1, casted.getFilters().size());
        filter = casted.getFilters().get(0);
        assertTrue(filter instanceof DateTimeFilter);
        castedFilter = (DateTimeFilter) filter;
        assertEquals(LocalDateTime.of(LocalDate.of(2016, 4, 5), LocalTime.MAX),
                castedFilter.getEnd());
        assertEquals(LocalDateTime.MIN, castedFilter.getStart());

        result = this.parser.parse("search between 5-4-2016 and 6-5-2016");
        assertTrue(result instanceof SearchCommand);
        casted = (SearchCommand) result;
        assertEquals(1, casted.getFilters().size());
        filter = casted.getFilters().get(0);
        assertTrue(filter instanceof DateTimeFilter);
        castedFilter = (DateTimeFilter) filter;
        assertEquals(LocalDateTime.of(LocalDate.of(2016, 4, 5), LocalTime.MIN),
                castedFilter.getStart());
        assertEquals(LocalDateTime.of(LocalDate.of(2016, 5, 6), LocalTime.MAX),
                castedFilter.getEnd());
    }

    @Test
    public void testDateTime() {
        Command result = this.parser.parse("search after 2pm 5th April 2016");
        assertTrue(result instanceof SearchCommand);
        SearchCommand casted = (SearchCommand) result;
        assertEquals(1, casted.getFilters().size());
        Filter filter = casted.getFilters().get(0);
        assertTrue(filter instanceof DateTimeFilter);
        DateTimeFilter castedFilter = (DateTimeFilter) filter;
        assertEquals(LocalDateTime.of(LocalDate.of(2016, 4, 5), LocalTime.of(14, 0)),
                castedFilter.getStart());
        assertEquals(LocalDateTime.MAX, castedFilter.getEnd());

        result = this.parser.parse("search before 5-4-2016 10");
        assertTrue(result instanceof SearchCommand);
        casted = (SearchCommand) result;
        assertEquals(1, casted.getFilters().size());
        filter = casted.getFilters().get(0);
        assertTrue(filter instanceof DateTimeFilter);
        castedFilter = (DateTimeFilter) filter;
        assertEquals(LocalDateTime.of(LocalDate.of(2016, 4, 5), LocalTime.of(10, 0)),
                castedFilter.getEnd());
        assertEquals(LocalDateTime.MIN, castedFilter.getStart());

        result = this.parser.parse("search between 5-4-2016 11am and 6-5-2016 5.30pm");
        assertTrue(result instanceof SearchCommand);
        casted = (SearchCommand) result;
        assertEquals(1, casted.getFilters().size());
        filter = casted.getFilters().get(0);
        assertTrue(filter instanceof DateTimeFilter);
        castedFilter = (DateTimeFilter) filter;
        assertEquals(LocalDateTime.of(LocalDate.of(2016, 4, 5), LocalTime.of(11, 0)),
                castedFilter.getStart());
        assertEquals(LocalDateTime.of(LocalDate.of(2016, 5, 6), LocalTime.of(17, 30)),
                castedFilter.getEnd());
    }

    @Test
    public void testWeek() {
        Command result = this.parser.parse("search this week");
        assertTrue(result instanceof SearchCommand);
        SearchCommand casted = (SearchCommand) result;
        assertEquals(1, casted.getFilters().size());
        Filter filter = casted.getFilters().get(0);
        assertTrue(filter instanceof DateTimeFilter);
        DateTimeFilter castedFilter = (DateTimeFilter) filter;
        LocalDateTime now = LocalDateTime.now();
        assertEquals(now.with(DayOfWeek.MONDAY).with(LocalTime.MIN),
                castedFilter.getStart());
        assertEquals(now.with(DayOfWeek.SUNDAY).with(LocalTime.MAX),
                castedFilter.getEnd());

        result = this.parser.parse("search next week");
        assertTrue(result instanceof SearchCommand);
        casted = (SearchCommand) result;
        assertEquals(1, casted.getFilters().size());
        filter = casted.getFilters().get(0);
        assertTrue(filter instanceof DateTimeFilter);
        castedFilter = (DateTimeFilter) filter;
        assertEquals(now.plusWeeks(1).with(DayOfWeek.MONDAY).with(LocalTime.MIN),
                castedFilter.getStart());
        assertEquals(now.plusWeeks(1).with(DayOfWeek.SUNDAY).with(LocalTime.MAX),
                castedFilter.getEnd());
    }

    @Test
    public void testMonth() {
        Command result = this.parser.parse("search this month");
        assertTrue(result instanceof SearchCommand);
        SearchCommand casted = (SearchCommand) result;
        assertEquals(1, casted.getFilters().size());
        Filter filter = casted.getFilters().get(0);
        assertTrue(filter instanceof DateTimeFilter);
        DateTimeFilter castedFilter = (DateTimeFilter) filter;
        LocalDateTime now = LocalDateTime.now();
        assertEquals(now.withDayOfMonth(1).with(LocalTime.MIN),
                castedFilter.getStart());
        assertEquals(
                now.withDayOfMonth(1).plusMonths(1).minusDays(1).with(LocalTime.MAX),
                castedFilter.getEnd());

        result = this.parser.parse("search next month");
        assertTrue(result instanceof SearchCommand);
        casted = (SearchCommand) result;
        assertEquals(1, casted.getFilters().size());
        filter = casted.getFilters().get(0);
        assertTrue(filter instanceof DateTimeFilter);
        castedFilter = (DateTimeFilter) filter;
        assertEquals(now.plusMonths(1).withDayOfMonth(1).with(LocalTime.MIN),
                castedFilter.getStart());
        assertEquals(
                now.withDayOfMonth(1).plusMonths(2).minusDays(1).with(LocalTime.MAX),
                castedFilter.getEnd());
    }

    @Test
    public void testOverdue() {
        Command result = this.parser.parse("search overdue");
        assertTrue(result instanceof SearchCommand);
        SearchCommand casted = (SearchCommand) result;
        assertEquals(1, casted.getFilters().size());
        Filter filter = casted.getFilters().get(0);
        assertTrue(filter instanceof OverdueFilter);
    }
}
```
